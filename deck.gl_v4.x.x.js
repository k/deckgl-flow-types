/* @flow */
// flow-typed signature: b14f839768d0e48c38686ddce2a7936d
// flow-typed version: <<STUB>>/deck.gl_v4.x.x/flow_v0.56.0

/**
 * This is an autogenerated libdef stub for:
 *
 *   'deck.gl'
 *
 * Fill this stub out by replacing all the `any` types.
 *
 * Once filled out, we encourage you to share your work with the
 * community by sending a pull request to:
 * https://github.com/flowtype/flow-typed
 */

import * as React from 'react';
import type { FeatureCollection, Feature } from '@aot/geojson-flow';

declare module 'deck.gl' {
    // Color Types
    /** [Red, Green, Blue] */
    declare export type ColorNoAlpha = [number, number, number];
    /** [Red, Green, Blue, Alpha] */
    declare export type ColorWithAlpha = [number, number, number, number];
    declare export type Color = ColorNoAlpha | ColorWithAlpha;

    // Location Types
    /** [Long, Lat] */
    declare export type LongLat = [number, number];
    /** [Long, Lat, Altitude] */
    declare export type LongLatAlt = [number, number, number];
    declare export type Location = LongLat | LongLatAlt;

    // Pixel types
    /** [x, y] */
    declare export type PixelXY = [number, number];

    declare export type Viewport = {
        width: number,
        height: number,
        latitude: number,
        longitude: number,
        zoom: number,
        bearing?: number,
        pitch?: number,
        farZMultiplier?: number,
    };

    declare export type DeckInfo<T> = {
        layer: Layer<T>,
        index: number,
        object: T,
        x: number,
        y: number,
        lngLat: LongLat,
    };

    declare export type DeckFunctionEvent<T> = (
        info?: DeckInfo<T>,
        pickedInfos?: Array<DeckInfo<mixed>>,
        event?: SyntheticInputEvent<>,
    ) => void;

    declare export type DeckGlQuery = {
        x: number,
        y: number,
        layerIds?: Array<string>,
    };
    declare export type DeckGlQueryObject = DeckGlQuery & {
        radius?: number,
    };

    declare export type DeckGlQueryVisibleObjects = DeckGlQuery & {
        width?: number, // default 1
        height?: number, // default 1
    };

    declare export type Number16 = [
        number,
        number,
        number,
        number,
        number,
        number,
        number,
        number,
        number,
        number,
        number,
        number,
        number,
        number,
        number,
        number,
    ];

    declare export type LayerProps<Data> = {
        // Basic Props
        id?: string,
        +data?: Array<Data> | mixed,
        visible?: boolean,
        opacity: number,

        // Interaction Props
        pickable?: boolean,
        onHover?: DeckFunctionEvent<Data>,
        onClick?: DeckFunctionEvent<Data>,
        highlightColor?: Color,
        highlightedObjectIndex?: number, // integer
        autoHighlight?: boolean,

        // Coordinate System Props
        coordinateSystem?: number,
        coordinateOrigin?: [number, number],
        modelMatrix?: Number16,

        // Data Props
        dataComparator?: (newData: Array<Data>, oldData: Array<Data>) => boolean, // used to override default shallow comparison of data object
        numInstances?: number,
        updateTriggers?: Object,

        // Render Props
        parameters?: Function,
        getPolygonOffset?: ({ layerIndex: number }) => [number, number],
    };

    declare export type LayerFlags = {
        dataChanged: boolean,
        propChanged: boolean,
        viewportChanged: boolean,
        somethingChanged: boolean,
    };

    declare export type StateUpdateArgs<Data> = {
        props: LayerProps<Data>,
        oldProps: LayerProps<Data>,
        context: Object,
        oldContext: Object,
        changeFlags: LayerFlags,
    };

    declare export class Layer<Data> {
        static layerName: *;
        static defaultProps?: Object;
        constructor(props: LayerProps<Data>): Layer<Data>;

        // Members
        +context: Object;
        +state: Object;
        +props: LayerProps<Data>;

        // General Methods
        setState: Function;

        // Layer Lifecycle Methods
        +initializeState: () => void;
        +shouldUpdateState: (obj: StateUpdateArgs<Data>) => boolean;
        +updateState: (obj: StateUpdateArgs<Data>) => void;
        +draw: Function;
        +getPickingInfo: (pickParams: {
            info: DeckInfo<Data>,
            mode: 'hover' | 'click',
        }) => DeckInfo<Data> | null;
        +finalizeState: Function;

        // Projection Methods
        project: <T: Location>(coords: T, opts: { topLeft?: boolean }) => T;
        unproject: <T: Location>(coords: T, opts: { topLeft?: boolean }) => T;
        projectFlat: (coords: LongLat, scale: number) => PixelXY;
        unprojectFlat: (pixels: PixelXY, scale: number) => LongLat;
        screenToDevicePixels: (pixels: number) => number;

        // Layer Picking methods
        decodePickingColor: (color: ColorNoAlpha) => number;
        encodePickingColor: (index: number) => ColorNoAlpha;
        nullPickingColor: () => ColorNoAlpha;
    }

    declare export type DeckGlProps = {
        id?: string, // Canvas ID to allow style customization in CSS
        children: React.Node, // Tries to viewportId to viewport if prop exists
        viewports: Viewport | Array<Viewport>,
        layers: Array<Layer<mixed>>,
        width: number,
        height: number,
        latitude?: number,
        longitude?: number,
        zoom?: number,
        bearing?: number,
        pitch?: number,
        style: Object,
        pickingRadius?: number, // default 0
        useDevicePixelRatio?: boolean, // default false. When true, device's full resolution will be used for rendering
        gl?: Object, // will be autocreated if not supplied
        debug?: boolean, // default false
        initWebGlParameters?: boolean,
        onWebGlInitialized?: (glContext: Object) => void,
        onLayerHover?: DeckFunctionEvent<*>,
        onLayerClick?: DeckFunctionEvent<*>,
    };

    declare class DeckGl extends React.Component<DeckGlProps> {
        queryObject: (obj: DeckGlQueryObject) => ?DeckInfo<*>;
        queryVisibleObjects: (obj: DeckGlQueryVisibleObjects) => Array<DeckInfo<*>>;
    }

    declare export default typeof DeckGl

    declare export type GeoJsonLayerProps<T: {}> = LayerProps<Feature<T>> & {
        /**
         * Geojson
         */
        data: FeatureCollection<T>,
        /**
         * Fills Polygons
         */
        filled?: boolean,
        stroked?: boolean,
        extruded?: boolean,

        wireframe?: boolean,
        lineWidthScale?: number,
        lineWidthMinPixels?: number,
        lineWidthMaxPixels?: number,
        lineJointRounded?: boolean,
        lineMiterLimit?: number,
        pointRadiusScale?: number,
        pointRadiusMinPixels?: number,
        pointRadiusMaxPixels?: number,
        fp64?: boolean,

        // Interactivity
        getLineColor?: (f: Feature<T>) => Color, // default f => f.properties.lineColor || [0, 0, 0, 255]
        getFillColor?: (f: Feature<T>) => Color, // default f => f.properties.fillColor || [0, 0, 0, 255]
        getRadius?: (f: Feature<T>) => number, // default f.properties.radius || f.properties.size
        getLineWidth?: (f: Feature<T>) => number, // default f => f.properties.lineWidth || 1
        getElevation?: (f: Feature<T>) => number, // (extruded: true) default f => f.properties.elevation || 1000
    };

    declare export class GeoJsonLayer<T: {}> extends Layer<FeatureCollection<T>> {
        constructor(props: GeoJsonLayerProps<T>): GeoJsonLayer<T>;
        static layerName: 'GeoJsonLayer';
        +state: { features: Array<Feature<T>> };
    }

    // IconLayer

    declare export type Icon = {
        position: [number, number], // lat, long
        icon: string,
        size?: number, // default 1
        color?: Color, // default [0, 0, 0, 255]
        angle?: number,
    };

    declare export type IconMapping = {
        x: number,
        y: number,
        width: number,
        height: number,
        anchorX?: number, // default half width
        anchorY?: number, // default half height
        mask?: boolean, // default false
    };

    declare export type IconLayerProps<T: Icon> = LayerProps<Array<T>> & {
        /** Image or Sprite Sheeet */
        iconAtlas: string,

        /** Mapping of string to location in iconAtlas */
        iconMapping: IconMapping,

        /** Icon size multiplier */
        sizeScale?: number,

        fp64?: boolean, // default: false

        /** Dynamically change the location of the icon */
        getPosition?: (d: T) => [number, number, number], // lat, long, z

        /** Dynamically change the image taken from the SPrite sheet */
        getIcon?: (d: T) => string,

        /** Dynamically change the size of an icon */
        getSize?: (d: T) => number,

        /** Dynamically change the color of an icon */
        getColor?: (d: T) => Color,

        /** Dynamically change the angle of an icon */
        getAngle?: (d: T) => number,
    };

    declare export class IconLayer<T: Icon> extends Layer<Array<T>> {
        constructor(props: IconLayerProps<T>): IconLayer<T>;
        static layerName: 'IconLayer';
    }

    // PathLayer
    declare type Path = {
        path: Array<LongLat>,
        color: Color,
        width: number,
    };

    declare type PathLayerOptions = {
        // TODO:
    };
}
